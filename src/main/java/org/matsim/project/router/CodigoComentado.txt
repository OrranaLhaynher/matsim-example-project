/*Map<Double, Path> travelLength = new HashMap<Double, Path>();
		double[] cLength = new double[path.size()];

		double x = getLinkTravelDisutility(path.get(1).links, 0.0, null, null);
		System.out.println(x);

		for (int i = 0; i < cLength.length; i++) {
			System.out.println(path.get(i).links.iterator().next());
		}

		for (int i = 0; i < cLength.length; i++) {
			cLength[i] = cLength1.getLinkTravelDisutility(path.get(i).links.iterator().next(), 0.0, null, null);
		}

		
		for (int i = 0; i < path.size(); i++) {
			travelLength.put(cLength.getLinkTravelDisutility(path.get(i).links.get(i),0.0, null, null), path.get(i)); 
		}
		
		int i = 0;
		Double[] key1 = new Double[5];

		for (Double key : travelLength.keySet()) {
			key1[i] = key;
			System.out.println(key1[i]);
			i++;
		}

		System.out.println(travelLength.entrySet());

		if (key1[0] < key1[1] && key1[0] < key1[2] && key1[0] < key1[3] && key1[0] < key1[4]) {
			Coord n = travelLength.get(key1[0]).getToNode().getCoord();
			return n;
		} else if (key1[1] < key1[0] && key1[1] < key1[2] && key1[1] < key1[3] && key1[1] < key1[4]) {
			Coord n = travelLength.get(key1[1]).getToNode().getCoord();
			return n;
		} else if (key1[2] < key1[1] && key1[2] < key1[0] && key1[2] < key1[3] && key1[2] < key1[4]) {
			Coord n = travelLength.get(key1[2]).getToNode().getCoord();
			return n;
		} else if (key1[3] < key1[1] && key1[3] < key1[2] && key1[3] < key1[0] && key1[3] < key1[4]) {
			Coord n = travelLength.get(key1[3]).getToNode().getCoord();
			return n;
		} else {
			Coord n1 = travelLength.get(key1[4]).getToNode().getCoord();
			return n1;
		}*/

		/*Coordinate c0 = MGC.coord2Coordinate(link.getFromNode().getCoord());
		Coordinate c1 = MGC.coord2Coordinate(link.getToNode().getCoord());
		LineString ls = this.geofac.createLineString(new Coordinate[]{c0,c1});
		if (ls.intersects(this.p) || this.p.covers(ls)) {
			return Double.POSITIVE_INFINITY;
		}*/